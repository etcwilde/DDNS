May 9 2015 | Starting the implementation | Evan Wilde

Implementation began in python 3.x. We add the chord node, which is a
collection of the successor node, the predecessor node, the finger table, and
the nodes unique id. We also add the chord key, which is used for looking up a
specific node (It is the key in the hash table). Chord uses the SHA1 algorithm,
though it may be interesting to look into implementing chord with other hashing
algorithms and see how they distribute the values.

May 16 2015 | Reimplementing in C++ | Evan Wilde

I've switched to using C++ as the implementation language. I've gone ahead and
implemented a simple C++ SHA1 hash wrapper class for the OpenSSL functions.
I've reimplemented the chord key, but in C++. The keys are comparable based on
the last 32 bits. This lets us determine an ordering of keeping the keys in the
Chord ring. We can get the id used to generate the key and we can get the hash
key. Finally, the chord node has been reimplemented in C++.

May 19 2015 | Chord Algorithm and Fingers | Evan Wilde

I've started implementing the larger overall manager of the chord system. This
joins nodes together to help build the Chord ring. I've also started
implementing the finger tables, which bring the number of lookups down from
O(n) to O(log n).

May 20 2015 | Socket Interface | Evan Wilde

I've started implementing a basic socket interface for C++ which allows an easy
way of transferring a message across a socket. I also started making the logs
about what is happening in the project, and I wrote the logs for the things
that have happened in the past as well.

May 21 2015 | UDP Socket Interface | Evan Wilde

Today I got a simple UDP socket interface working. I'll be adding a reliable
socket interface next since that is what I want. I may add a TCP interface if
it is simple, just for completeness of the wrapper. I've got a very simple
client-server setup right now.
